<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Azure Key Vault VRF signer for cloud-native production workloads"><title>AzureKeyVaultVrfSigner in cardano_vrf::hsm::azure_keyvault - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="cardano_vrf" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0 (f8297e351 2025-10-28)" data-channel="1.91.0" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">AzureKeyVaultVrfSigner</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../cardano_vrf/index.html">cardano_<wbr>vrf</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Azure<wbr>KeyVault<wbr>VrfSigner</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#status" title="Status">Status</a></li><li><a href="#thread-safety" title="Thread Safety">Thread Safety</a></li><li><a href="#security-properties" title="Security Properties">Security Properties</a><ul><li><a href="#premium-tier-hsm-backed" title="Premium Tier (HSM-backed)">Premium Tier (HSM-backed)</a></li><li><a href="#standard-tier-software-protected" title="Standard Tier (software-protected)">Standard Tier (software-protected)</a></li></ul></li><li><a href="#examples" title="Examples">Examples</a><ul><li><a href="#with-service-principal" title="With Service Principal">With Service Principal</a></li><li><a href="#thread-safe-sharing" title="Thread-safe Sharing">Thread-safe Sharing</a></li></ul></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.new" title="new">new</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-HsmVrfSigner-for-AzureKeyVaultVrfSigner" title="HsmVrfSigner">HsmVrfSigner</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-AzureKeyVaultVrfSigner" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-AzureKeyVaultVrfSigner" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-AzureKeyVaultVrfSigner" title="Send">Send</a></li><li><a href="#impl-Sync-for-AzureKeyVaultVrfSigner" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-AzureKeyVaultVrfSigner" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-AzureKeyVaultVrfSigner" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-Same-for-T" title="Same">Same</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In cardano_<wbr>vrf::<wbr>hsm::<wbr>azure_<wbr>keyvault</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">cardano_vrf</a>::<wbr><a href="../index.html">hsm</a>::<wbr><a href="index.html">azure_keyvault</a></div><h1>Struct <span class="struct">Azure<wbr>KeyVault<wbr>VrfSigner</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/cardano_vrf/hsm/azure_keyvault.rs.html#521-530">Source</a> </span></div><pre class="rust item-decl"><code>pub struct AzureKeyVaultVrfSigner { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Azure Key Vault VRF signer for cloud-native production workloads</p>
<p>Provides VRF operations using Azure Key Vault Premium tier with HSM backing.
Offers FIPS 140-2 Level 3 validated security with Azure AD integration for
authentication and RBAC.</p>
<h2 id="status"><a class="doc-anchor" href="#status">§</a>Status</h2>
<p>⚠️ <strong>IMPLEMENTATION PENDING</strong> - This is currently a placeholder structure.</p>
<h2 id="thread-safety"><a class="doc-anchor" href="#thread-safety">§</a>Thread Safety</h2>
<p>When implemented, Azure SDK clients are designed to be thread-safe and can
be shared across threads using <code>Arc&lt;...&gt;</code> without additional synchronization.</p>
<h2 id="security-properties"><a class="doc-anchor" href="#security-properties">§</a>Security Properties</h2><h3 id="premium-tier-hsm-backed"><a class="doc-anchor" href="#premium-tier-hsm-backed">§</a>Premium Tier (HSM-backed)</h3>
<ul>
<li><strong>FIPS 140-2 Level 3</strong> certified HSMs (Thales nShield)</li>
<li><strong>Multi-tenant</strong> with logical isolation per vault</li>
<li><strong>Azure AD authentication</strong> with OAuth 2.0</li>
<li><strong>Audit logging</strong> to Azure Monitor</li>
</ul>
<h3 id="standard-tier-software-protected"><a class="doc-anchor" href="#standard-tier-software-protected">§</a>Standard Tier (software-protected)</h3>
<ul>
<li><strong>FIPS 140-2 Level 2</strong> software protection</li>
<li>Lower cost for non-production use</li>
</ul>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2><h3 id="with-service-principal"><a class="doc-anchor" href="#with-service-principal">§</a>With Service Principal</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>cardano_vrf::hsm::azure_keyvault::AzureKeyVaultVrfSigner;

<span class="kw">let </span>signer = AzureKeyVaultVrfSigner::new(
    <span class="string">"https://cardano-vrf-kv.vault.azure.net"</span>.to_string(),
    <span class="string">"your-client-id-guid"</span>.to_string(),
    <span class="string">"your-client-secret"</span>.to_string(),
    <span class="string">"your-tenant-id-guid"</span>.to_string()
)<span class="question-mark">?</span>;</code></pre></div><h3 id="thread-safe-sharing"><a class="doc-anchor" href="#thread-safe-sharing">§</a>Thread-safe Sharing</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>cardano_vrf::hsm::azure_keyvault::AzureKeyVaultVrfSigner;
<span class="kw">use </span>std::sync::Arc;

<span class="kw">let </span>signer = Arc::new(AzureKeyVaultVrfSigner::new(
    <span class="string">"https://my-vault.vault.azure.net"</span>.to_string(),
    <span class="string">"client-id"</span>.to_string(),
    <span class="string">"client-secret"</span>.to_string(),
    <span class="string">"tenant-id"</span>.to_string()
)<span class="question-mark">?</span>);

<span class="comment">// Clone Arc for other threads
</span><span class="kw">let </span>signer_clone = Arc::clone(<span class="kw-2">&amp;</span>signer);
std::thread::spawn(<span class="kw">move </span>|| {
    <span class="comment">// Use signer_clone
</span>});</code></pre></div></div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-AzureKeyVaultVrfSigner" class="impl"><a class="src rightside" href="../../../src/cardano_vrf/hsm/azure_keyvault.rs.html#532-679">Source</a><a href="#impl-AzureKeyVaultVrfSigner" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.AzureKeyVaultVrfSigner.html" title="struct cardano_vrf::hsm::azure_keyvault::AzureKeyVaultVrfSigner">AzureKeyVaultVrfSigner</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../../src/cardano_vrf/hsm/azure_keyvault.rs.html#666-678">Source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>(
    vault_url: <a class="struct" href="https://doc.rust-lang.org/1.91.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>,
    client_id: <a class="struct" href="https://doc.rust-lang.org/1.91.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>,
    client_secret: <a class="struct" href="https://doc.rust-lang.org/1.91.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>,
    tenant_id: <a class="struct" href="https://doc.rust-lang.org/1.91.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>,
) -&gt; <a class="type" href="../../type.VrfResult.html" title="type cardano_vrf::VrfResult">VrfResult</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Creates a new Azure Key Vault VRF signer</p>
<p>Initializes connection parameters for Azure Key Vault. Actual authentication
and connection happens lazily on first cryptographic operation.</p>
<h5 id="arguments"><a class="doc-anchor" href="#arguments">§</a>Arguments</h5>
<ul>
<li>
<p><code>vault_url</code> - Full HTTPS URL of your Key Vault</p>
<ul>
<li>Format: <code>https://&lt;vault-name&gt;.vault.azure.net</code></li>
<li>Example: <code>https://cardano-vrf-kv.vault.azure.net</code></li>
<li>Find via: <code>az keyvault show --name &lt;vault-name&gt; --query properties.vaultUri</code></li>
</ul>
</li>
<li>
<p><code>client_id</code> - Azure AD application (client) ID (GUID format)</p>
<ul>
<li>Created via: <code>az ad sp create-for-rbac</code></li>
<li>Format: <code>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</code></li>
<li>Also called “Application ID”</li>
</ul>
</li>
<li>
<p><code>client_secret</code> - Azure AD application client secret</p>
<ul>
<li>Generated when creating service principal</li>
<li>Should be stored in Azure Key Vault or environment variable</li>
<li>Expires (typically 1-2 years) and needs rotation</li>
</ul>
</li>
<li>
<p><code>tenant_id</code> - Azure AD tenant ID (GUID format)</p>
<ul>
<li>Find via: <code>az account show --query tenantId</code></li>
<li>Format: <code>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</code></li>
<li>Also called “Directory ID”</li>
</ul>
</li>
</ul>
<h5 id="returns"><a class="doc-anchor" href="#returns">§</a>Returns</h5>
<p>Returns a new <code>AzureKeyVaultVrfSigner</code> instance.</p>
<h5 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h5>
<p>Currently returns <code>Ok(...)</code> as this is a placeholder. When implemented:</p>
<ul>
<li><code>InvalidInput</code>: Invalid vault URL format</li>
<li><code>InvalidInput</code>: Invalid GUID format for client_id/tenant_id</li>
<li><code>InvalidInput</code>: Missing Azure SDK dependencies</li>
</ul>
<h5 id="security"><a class="doc-anchor" href="#security">§</a>Security</h5>
<p>⚠️ <strong>CRITICAL SECURITY NOTES</strong>:</p>
<ul>
<li><strong>DO NOT</strong> hardcode client_secret in source code</li>
<li><strong>DO</strong> use environment variables or Azure Key Vault for secrets</li>
<li><strong>DO</strong> prefer Managed Identity over service principals when possible</li>
<li><strong>DO</strong> rotate secrets every 90 days</li>
<li><strong>DO</strong> use separate service principals for dev/staging/prod</li>
</ul>
<h5 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h5><h6 id="development-environment-variables"><a class="doc-anchor" href="#development-environment-variables">§</a>Development (Environment Variables)</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>cardano_vrf::hsm::azure_keyvault::AzureKeyVaultVrfSigner;

<span class="kw">let </span>signer = AzureKeyVaultVrfSigner::new(
    std::env::var(<span class="string">"AZURE_KEYVAULT_URL"</span>)<span class="question-mark">?</span>,
    std::env::var(<span class="string">"AZURE_CLIENT_ID"</span>)<span class="question-mark">?</span>,
    std::env::var(<span class="string">"AZURE_CLIENT_SECRET"</span>)<span class="question-mark">?</span>,
    std::env::var(<span class="string">"AZURE_TENANT_ID"</span>)<span class="question-mark">?</span>,
)<span class="question-mark">?</span>;</code></pre></div><h6 id="production-managed-identity---future-implementation"><a class="doc-anchor" href="#production-managed-identity---future-implementation">§</a>Production (Managed Identity - future implementation)</h6>
<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="comment">// When using Managed Identity on Azure VM/AKS, no credentials needed:
</span><span class="kw">use </span>azure_identity::DefaultAzureCredential;
<span class="kw">use </span>azure_security_keyvault::KeyClient;

<span class="kw">let </span>credential = DefaultAzureCredential::default();
<span class="kw">let </span>client = KeyClient::new(vault_url, Arc::new(credential))<span class="question-mark">?</span>;
<span class="comment">// No client_id/secret/tenant_id required!</span></code></pre></div><h6 id="from-configuration-file"><a class="doc-anchor" href="#from-configuration-file">§</a>From Configuration File</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>cardano_vrf::hsm::azure_keyvault::AzureKeyVaultVrfSigner;

<span class="kw">let </span>config = load_config(); <span class="comment">// Your config loading logic

</span><span class="kw">let </span>signer = AzureKeyVaultVrfSigner::new(
    config.get(<span class="string">"vault_url"</span>).unwrap().clone(),
    config.get(<span class="string">"client_id"</span>).unwrap().clone(),
    config.get(<span class="string">"client_secret"</span>).unwrap().clone(),
    config.get(<span class="string">"tenant_id"</span>).unwrap().clone(),
)<span class="question-mark">?</span>;</code></pre></div><h6 id="multi-environment-setup"><a class="doc-anchor" href="#multi-environment-setup">§</a>Multi-Environment Setup</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>cardano_vrf::hsm::azure_keyvault::AzureKeyVaultVrfSigner;

<span class="kw">let </span>env = std::env::var(<span class="string">"ENVIRONMENT"</span>).unwrap_or_else(|<span class="kw">_</span>| <span class="string">"dev"</span>.to_string());

<span class="kw">let </span>(vault_url, client_id, secret, tenant) = <span class="kw">match </span>env.as_str() {
    <span class="string">"prod" </span>=&gt; (
        std::env::var(<span class="string">"PROD_VAULT_URL"</span>)<span class="question-mark">?</span>,
        std::env::var(<span class="string">"PROD_CLIENT_ID"</span>)<span class="question-mark">?</span>,
        std::env::var(<span class="string">"PROD_CLIENT_SECRET"</span>)<span class="question-mark">?</span>,
        std::env::var(<span class="string">"PROD_TENANT_ID"</span>)<span class="question-mark">?</span>,
    ),
    <span class="string">"staging" </span>=&gt; (
        std::env::var(<span class="string">"STAGING_VAULT_URL"</span>)<span class="question-mark">?</span>,
        std::env::var(<span class="string">"STAGING_CLIENT_ID"</span>)<span class="question-mark">?</span>,
        std::env::var(<span class="string">"STAGING_CLIENT_SECRET"</span>)<span class="question-mark">?</span>,
        std::env::var(<span class="string">"STAGING_TENANT_ID"</span>)<span class="question-mark">?</span>,
    ),
    <span class="kw">_ </span>=&gt; (
        std::env::var(<span class="string">"DEV_VAULT_URL"</span>)<span class="question-mark">?</span>,
        std::env::var(<span class="string">"DEV_CLIENT_ID"</span>)<span class="question-mark">?</span>,
        std::env::var(<span class="string">"DEV_CLIENT_SECRET"</span>)<span class="question-mark">?</span>,
        std::env::var(<span class="string">"DEV_TENANT_ID"</span>)<span class="question-mark">?</span>,
    ),
};

<span class="kw">let </span>signer = AzureKeyVaultVrfSigner::new(
    vault_url, client_id, secret, tenant
)<span class="question-mark">?</span>;</code></pre></div></div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-HsmVrfSigner-for-AzureKeyVaultVrfSigner" class="impl"><a class="src rightside" href="../../../src/cardano_vrf/hsm/azure_keyvault.rs.html#681-1113">Source</a><a href="#impl-HsmVrfSigner-for-AzureKeyVaultVrfSigner" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../trait.HsmVrfSigner.html" title="trait cardano_vrf::hsm::HsmVrfSigner">HsmVrfSigner</a> for <a class="struct" href="struct.AzureKeyVaultVrfSigner.html" title="struct cardano_vrf::hsm::azure_keyvault::AzureKeyVaultVrfSigner">AzureKeyVaultVrfSigner</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.prove" class="method trait-impl"><a class="src rightside" href="../../../src/cardano_vrf/hsm/azure_keyvault.rs.html#722-726">Source</a><a href="#method.prove" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.HsmVrfSigner.html#tymethod.prove" class="fn">prove</a>(&amp;self, _key_id: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.str.html">str</a>, _message: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.u8.html">u8</a>]) -&gt; <a class="type" href="../../type.VrfResult.html" title="type cardano_vrf::VrfResult">VrfResult</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.91.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.u8.html">u8</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>Generates a VRF proof using Azure Key Vault</p>
<h5 id="status-not-implemented"><a class="doc-anchor" href="#status-not-implemented">§</a>Status: NOT IMPLEMENTED</h5>
<p>Placeholder that returns an error. When implemented, will perform VRF
signing using Ed25519 key stored in Azure Key Vault (Premium tier with HSM).</p>
<h5 id="arguments-1"><a class="doc-anchor" href="#arguments-1">§</a>Arguments</h5>
<ul>
<li><code>key_id</code> - Name of the key in Key Vault (alphanumeric and hyphens only)</li>
<li><code>message</code> - Data to create VRF proof for</li>
</ul>
<h5 id="returns-1"><a class="doc-anchor" href="#returns-1">§</a>Returns</h5>
<p>When implemented, returns VRF proof (80 or 128 bytes depending on version).</p>
<h5 id="errors-1"><a class="doc-anchor" href="#errors-1">§</a>Errors</h5>
<p>Currently: <code>InvalidInput("Azure Key Vault not yet implemented...")</code></p>
<p>When implemented:</p>
<ul>
<li><code>KeyNotFound</code>: Key with given name doesn’t exist (404)</li>
<li><code>InvalidInput</code>: Authentication failed (401/403)</li>
<li><code>InvalidInput</code>: Rate limit exceeded (429)</li>
<li><code>InvalidInput</code>: Key Vault service unavailable (503)</li>
</ul>
<h5 id="azure-specific-notes"><a class="doc-anchor" href="#azure-specific-notes">§</a>Azure-Specific Notes</h5>
<ul>
<li>Uses REST API: <code>POST /keys/{key-name}/sign</code></li>
<li>Algorithm: <code>EdDSA</code> (Ed25519)</li>
<li>Requires RBAC role: <strong>Key Vault Crypto User</strong></li>
<li>Rate limit: 5000 requests per 10 seconds (Premium tier)</li>
<li>Typical latency: 50-100ms (same region)</li>
</ul>
<h5 id="performance-tips"><a class="doc-anchor" href="#performance-tips">§</a>Performance Tips</h5>
<ul>
<li>Cache Azure AD tokens (valid for 1 hour)</li>
<li>Use connection pooling for HTTP clients</li>
<li>Consider regional deployment for lower latency</li>
<li>Monitor with Application Insights for bottlenecks</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_public_key" class="method trait-impl"><a class="src rightside" href="../../../src/cardano_vrf/hsm/azure_keyvault.rs.html#792-796">Source</a><a href="#method.get_public_key" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.HsmVrfSigner.html#tymethod.get_public_key" class="fn">get_public_key</a>(&amp;self, _key_id: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.str.html">str</a>) -&gt; <a class="type" href="../../type.VrfResult.html" title="type cardano_vrf::VrfResult">VrfResult</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.u8.html">u8</a>; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.array.html">32</a>]&gt;</h4></section></summary><div class="docblock"><p>Retrieves public key from Azure Key Vault</p>
<h5 id="status-not-implemented-1"><a class="doc-anchor" href="#status-not-implemented-1">§</a>Status: NOT IMPLEMENTED</h5>
<p>When implemented, retrieves the 32-byte Ed25519 public key from Azure
Key Vault using the key name.</p>
<h5 id="arguments-2"><a class="doc-anchor" href="#arguments-2">§</a>Arguments</h5>
<ul>
<li><code>key_id</code> - Name of the key in Key Vault</li>
</ul>
<h5 id="returns-2"><a class="doc-anchor" href="#returns-2">§</a>Returns</h5>
<p>When implemented, returns 32-byte Ed25519 public key.</p>
<h5 id="errors-2"><a class="doc-anchor" href="#errors-2">§</a>Errors</h5>
<p>Currently: <code>InvalidInput("Azure Key Vault not yet implemented")</code></p>
<p>When implemented:</p>
<ul>
<li><code>KeyNotFound</code>: No key with given name exists (404)</li>
<li><code>InvalidInput</code>: Authentication failed (401/403)</li>
</ul>
<h5 id="azure-specific-notes-1"><a class="doc-anchor" href="#azure-specific-notes-1">§</a>Azure-Specific Notes</h5>
<ul>
<li>Uses REST API: <code>GET /keys/{key-name}</code></li>
<li>Public key in response: <code>key.n</code> field (base64url encoded)</li>
<li>Requires RBAC role: <strong>Key Vault Reader</strong> (or Crypto User)</li>
<li>Rate limit: 5000 requests per 10 seconds</li>
</ul>
<h5 id="performance"><a class="doc-anchor" href="#performance">§</a>Performance</h5>
<ul>
<li>First call: 20-50ms (REST API)</li>
<li><strong>CRITICAL</strong>: Cache result locally to avoid repeated API calls</li>
<li>Public keys rarely change - cache for duration of application</li>
<li>Consider using Azure CDN for global low-latency access</li>
</ul>
<h5 id="caching-example"><a class="doc-anchor" href="#caching-example">§</a>Caching Example</h5>
<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::HashMap;
<span class="kw">use </span>std::sync::RwLock;

<span class="kw">struct </span>CachingVrfSigner {
    vault: AzureKeyVaultVrfSigner,
    cache: RwLock&lt;HashMap&lt;String, [u8; <span class="number">32</span>]&gt;&gt;,
}

<span class="kw">impl </span>CachingVrfSigner {
    <span class="kw">fn </span>get_public_key(<span class="kw-2">&amp;</span><span class="self">self</span>, key_id: <span class="kw-2">&amp;</span>str) -&gt; VrfResult&lt;[u8; <span class="number">32</span>]&gt; {
        <span class="comment">// Try cache first
        </span><span class="kw">if let </span><span class="prelude-val">Some</span>(pk) = <span class="self">self</span>.cache.read().unwrap().get(key_id) {
            <span class="kw">return </span><span class="prelude-val">Ok</span>(<span class="kw-2">*</span>pk);
        }

        <span class="comment">// Fetch from Key Vault
        </span><span class="kw">let </span>pk = <span class="self">self</span>.vault.get_public_key(key_id)<span class="question-mark">?</span>;

        <span class="comment">// Cache for future
        </span><span class="self">self</span>.cache.write().unwrap().insert(key_id.to_string(), pk);
        <span class="prelude-val">Ok</span>(pk)
    }
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.generate_keypair" class="method trait-impl"><a class="src rightside" href="../../../src/cardano_vrf/hsm/azure_keyvault.rs.html#863-867">Source</a><a href="#method.generate_keypair" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.HsmVrfSigner.html#tymethod.generate_keypair" class="fn">generate_keypair</a>(&amp;self, _key_id: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.str.html">str</a>) -&gt; <a class="type" href="../../type.VrfResult.html" title="type cardano_vrf::VrfResult">VrfResult</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.u8.html">u8</a>; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.array.html">32</a>]&gt;</h4></section></summary><div class="docblock"><p>Generates new Ed25519 keypair in Azure Key Vault</p>
<h5 id="status-not-implemented-2"><a class="doc-anchor" href="#status-not-implemented-2">§</a>Status: NOT IMPLEMENTED</h5>
<p>When implemented, generates a new Ed25519 keypair in Azure Key Vault.
Private key is HSM-protected (Premium tier) and never leaves the vault.</p>
<h5 id="arguments-3"><a class="doc-anchor" href="#arguments-3">§</a>Arguments</h5>
<ul>
<li><code>key_id</code> - Name to assign to the new key
<ul>
<li>Must be 1-127 characters</li>
<li>Alphanumeric and hyphens only</li>
<li>Example: <code>validator-001</code>, <code>node-mainnet-key-1</code></li>
</ul>
</li>
</ul>
<h5 id="returns-3"><a class="doc-anchor" href="#returns-3">§</a>Returns</h5>
<p>When implemented, returns the 32-byte public key. Private key stays in vault.</p>
<h5 id="errors-3"><a class="doc-anchor" href="#errors-3">§</a>Errors</h5>
<p>Currently: <code>InvalidInput("Azure Key Vault not yet implemented")</code></p>
<p>When implemented:</p>
<ul>
<li><code>InvalidInput</code>: Key name already exists (409 Conflict)</li>
<li><code>InvalidInput</code>: Invalid key name format</li>
<li><code>InvalidInput</code>: Insufficient permissions (403)</li>
<li><code>InvalidInput</code>: Premium tier required for HSM (Standard doesn’t support HSM)</li>
</ul>
<h5 id="azure-specific-notes-2"><a class="doc-anchor" href="#azure-specific-notes-2">§</a>Azure-Specific Notes</h5>
<ul>
<li>Uses REST API: <code>POST /keys/{key-name}/create</code></li>
<li>Key type: <code>EC</code> (Elliptic Curve)</li>
<li>Curve: <code>Ed25519</code></li>
<li>Protection: <code>HSM</code> (Premium) or <code>software</code> (Standard)</li>
<li>Requires RBAC role: <strong>Key Vault Crypto Officer</strong></li>
</ul>
<h5 id="key-attributes"><a class="doc-anchor" href="#key-attributes">§</a>Key Attributes</h5>
<p>When creating keys, set these attributes:</p>
<div class="example-wrap"><pre class="language-json"><code>{
  &quot;kty&quot;: &quot;EC&quot;,
  &quot;crv&quot;: &quot;Ed25519&quot;,
  &quot;key_ops&quot;: [&quot;sign&quot;, &quot;verify&quot;],
  &quot;attributes&quot;: {
    &quot;enabled&quot;: true,
    &quot;exportable&quot;: false
  },
  &quot;tags&quot;: {
    &quot;purpose&quot;: &quot;cardano-vrf&quot;,
    &quot;environment&quot;: &quot;production&quot;
  }
}</code></pre></div><h5 id="performance-1"><a class="doc-anchor" href="#performance-1">§</a>Performance</h5>
<ul>
<li>Typical latency: 200-500ms</li>
<li>One-time operation (keys rarely generated)</li>
<li>Keys are available immediately after creation</li>
</ul>
<h5 id="soft-delete"><a class="doc-anchor" href="#soft-delete">§</a>Soft Delete</h5>
<p>If soft-delete is enabled (recommended), deleted key names cannot be
reused until purged or recovery period expires (default 90 days).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.delete_key" class="method trait-impl"><a class="src rightside" href="../../../src/cardano_vrf/hsm/azure_keyvault.rs.html#936-940">Source</a><a href="#method.delete_key" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.HsmVrfSigner.html#tymethod.delete_key" class="fn">delete_key</a>(&amp;self, _key_id: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.str.html">str</a>) -&gt; <a class="type" href="../../type.VrfResult.html" title="type cardano_vrf::VrfResult">VrfResult</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Deletes a key from Azure Key Vault</p>
<h5 id="status-not-implemented-3"><a class="doc-anchor" href="#status-not-implemented-3">§</a>Status: NOT IMPLEMENTED</h5>
<p>When implemented, deletes (or soft-deletes) the key from Azure Key Vault.</p>
<h5 id="arguments-4"><a class="doc-anchor" href="#arguments-4">§</a>Arguments</h5>
<ul>
<li><code>key_id</code> - Name of the key to delete</li>
</ul>
<h5 id="returns-4"><a class="doc-anchor" href="#returns-4">§</a>Returns</h5>
<p>When implemented, returns <code>Ok(())</code> on successful deletion.</p>
<h5 id="errors-4"><a class="doc-anchor" href="#errors-4">§</a>Errors</h5>
<p>Currently: <code>InvalidInput("Azure Key Vault not yet implemented")</code></p>
<p>When implemented:</p>
<ul>
<li><code>KeyNotFound</code>: No key with given name exists (404)</li>
<li><code>InvalidInput</code>: Insufficient permissions (403)</li>
<li><code>InvalidInput</code>: Purge protection enabled (can’t delete)</li>
</ul>
<h5 id="azure-specific-behavior"><a class="doc-anchor" href="#azure-specific-behavior">§</a>Azure-Specific Behavior</h5><h6 id="soft-delete-if-enabled---recommended"><a class="doc-anchor" href="#soft-delete-if-enabled---recommended">§</a>Soft Delete (if enabled - recommended)</h6>
<ul>
<li>Key is marked as deleted but recoverable</li>
<li>Recovery period: 7-90 days (configurable)</li>
<li>Can be recovered with <code>recover-deleted-key</code> API</li>
<li>Name cannot be reused until purged or period expires</li>
<li>Uses REST API: <code>DELETE /keys/{key-name}</code></li>
</ul>
<h6 id="purge-protection-if-enabled---highly-recommended"><a class="doc-anchor" href="#purge-protection-if-enabled---highly-recommended">§</a>Purge Protection (if enabled - highly recommended)</h6>
<ul>
<li>Prevents permanent deletion during recovery period</li>
<li>Protects against accidental data loss</li>
<li>Requires waiting for retention period before name reuse</li>
</ul>
<h6 id="hard-delete-soft-delete-disabled"><a class="doc-anchor" href="#hard-delete-soft-delete-disabled">§</a>Hard Delete (soft delete disabled)</h6>
<ul>
<li>Immediate permanent deletion</li>
<li><strong>NOT RECOMMENDED</strong> for production</li>
<li>No recovery possible</li>
<li>Name can be reused immediately</li>
</ul>
<h5 id="rbac-requirements"><a class="doc-anchor" href="#rbac-requirements">§</a>RBAC Requirements</h5>
<ul>
<li><strong>Key Vault Crypto Officer</strong> role required</li>
<li>Or custom role with <code>Microsoft.KeyVault/vaults/keys/delete/action</code></li>
</ul>
<h5 id="best-practices"><a class="doc-anchor" href="#best-practices">§</a>Best Practices</h5>
<ol>
<li><strong>Never disable soft delete in production</strong></li>
<li><strong>Always enable purge protection</strong></li>
<li><strong>Create manual backup before deletion</strong></li>
<li><strong>Verify key is not in use</strong> by any application</li>
<li><strong>Audit log review</strong> after deletion</li>
<li>Consider <strong>key deactivation</strong> instead of deletion</li>
</ol>
<h5 id="deactivation-vs-deletion"><a class="doc-anchor" href="#deactivation-vs-deletion">§</a>Deactivation vs Deletion</h5>
<p>For compliance, consider deactivating instead:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="comment">// Set enabled = false instead of deleting
</span>client.update_key(key_name)
    .enabled(<span class="bool-val">false</span>)
    .tags((<span class="string">"status"</span>, <span class="string">"deactivated"</span>))
    .<span class="kw">await</span><span class="question-mark">?</span>;</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.list_keys" class="method trait-impl"><a class="src rightside" href="../../../src/cardano_vrf/hsm/azure_keyvault.rs.html#1011-1015">Source</a><a href="#method.list_keys" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.HsmVrfSigner.html#tymethod.list_keys" class="fn">list_keys</a>(&amp;self) -&gt; <a class="type" href="../../type.VrfResult.html" title="type cardano_vrf::VrfResult">VrfResult</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.91.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.91.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>Lists all VRF key names in Azure Key Vault</p>
<h5 id="status-not-implemented-4"><a class="doc-anchor" href="#status-not-implemented-4">§</a>Status: NOT IMPLEMENTED</h5>
<p>When implemented, enumerates all Ed25519 keys in the vault and returns
their names.</p>
<h5 id="returns-5"><a class="doc-anchor" href="#returns-5">§</a>Returns</h5>
<p>When implemented, returns vector of key name strings.</p>
<h5 id="errors-5"><a class="doc-anchor" href="#errors-5">§</a>Errors</h5>
<p>Currently: <code>InvalidInput("Azure Key Vault not yet implemented")</code></p>
<p>When implemented:</p>
<ul>
<li><code>InvalidInput</code>: Authentication failed (401/403)</li>
<li><code>InvalidInput</code>: Rate limit exceeded (429)</li>
</ul>
<h5 id="azure-specific-notes-3"><a class="doc-anchor" href="#azure-specific-notes-3">§</a>Azure-Specific Notes</h5>
<ul>
<li>Uses REST API: <code>GET /keys</code> (paginated)</li>
<li>Returns all key versions or just latest (configurable)</li>
<li>Requires RBAC role: <strong>Key Vault Reader</strong></li>
<li>Rate limit: 5000 requests per 10 seconds</li>
</ul>
<h5 id="pagination"><a class="doc-anchor" href="#pagination">§</a>Pagination</h5>
<p>Key Vault uses pagination for large result sets:</p>
<ul>
<li>Default page size: 25 keys</li>
<li>Maximum: No hard limit</li>
<li>Use <code>nextLink</code> for continuation</li>
</ul>
<h5 id="filtering"><a class="doc-anchor" href="#filtering">§</a>Filtering</h5>
<p>When implemented, should filter for Ed25519 keys only:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">let </span>all_keys = client.list_keys().<span class="kw">await</span><span class="question-mark">?</span>;
<span class="kw">let </span>ed25519_keys: Vec&lt;String&gt; = all_keys
    .into_iter()
    .filter(|k| k.key_type == <span class="string">"EC" </span>&amp;&amp; k.curve == <span class="string">"Ed25519"</span>)
    .map(|k| k.name)
    .collect();</code></pre></div><h5 id="performance-2"><a class="doc-anchor" href="#performance-2">§</a>Performance</h5>
<p>Performance depends on total number of keys:</p>
<ul>
<li>10 keys: ~50ms</li>
<li>100 keys: ~200ms</li>
<li>1000 keys: ~2s (multiple pages)</li>
</ul>
<h5 id="tags-for-organization"><a class="doc-anchor" href="#tags-for-organization">§</a>Tags for Organization</h5>
<p>Use tags to filter VRF keys:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="comment">// When creating keys, add tags:
</span>tags: {
    <span class="string">"purpose"</span>: <span class="string">"cardano-vrf"</span>,
    <span class="string">"validator"</span>: <span class="string">"pool-001"
</span>}

<span class="comment">// When listing, filter by tags:
</span><span class="kw">let </span>vrf_keys: Vec&lt;String&gt; = all_keys
    .into_iter()
    .filter(|k| k.tags.get(<span class="string">"purpose"</span>) == <span class="prelude-val">Some</span>(<span class="string">"cardano-vrf"</span>))
    .map(|k| k.name)
    .collect();</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.health_check" class="method trait-impl"><a class="src rightside" href="../../../src/cardano_vrf/hsm/azure_keyvault.rs.html#1108-1112">Source</a><a href="#method.health_check" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.HsmVrfSigner.html#tymethod.health_check" class="fn">health_check</a>(&amp;self) -&gt; <a class="type" href="../../type.VrfResult.html" title="type cardano_vrf::VrfResult">VrfResult</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Checks Azure Key Vault service health</p>
<h5 id="status-not-implemented-5"><a class="doc-anchor" href="#status-not-implemented-5">§</a>Status: NOT IMPLEMENTED</h5>
<p>When implemented, verifies:</p>
<ul>
<li>Azure AD authentication works</li>
<li>Key Vault endpoint is accessible</li>
<li>RBAC permissions are correct</li>
<li>Service is responsive</li>
</ul>
<h5 id="returns-6"><a class="doc-anchor" href="#returns-6">§</a>Returns</h5>
<p>When implemented, returns <code>Ok(())</code> if vault is healthy and accessible.</p>
<h5 id="errors-6"><a class="doc-anchor" href="#errors-6">§</a>Errors</h5>
<p>Currently: <code>InvalidInput("Azure Key Vault not yet implemented")</code></p>
<p>When implemented:</p>
<ul>
<li><code>InvalidInput</code>: Authentication failed (401)</li>
<li><code>InvalidInput</code>: Insufficient permissions (403)</li>
<li><code>InvalidInput</code>: Vault not found (404)</li>
<li><code>InvalidInput</code>: Service degraded (503)</li>
</ul>
<h5 id="health-check-implementation"><a class="doc-anchor" href="#health-check-implementation">§</a>Health Check Implementation</h5>
<p>Recommended checks:</p>
<ol>
<li><strong>Token acquisition</strong>: Can we get Azure AD token?</li>
<li><strong>Vault accessibility</strong>: Can we reach the vault endpoint?</li>
<li><strong>Permission test</strong>: Can we list keys (read permission)?</li>
<li><strong>Response time</strong>: Is latency acceptable (&lt;1s)?</li>
</ol>
<h5 id="performance-3"><a class="doc-anchor" href="#performance-3">§</a>Performance</h5>
<ul>
<li>Typical latency: 10-30ms</li>
<li>Does NOT perform cryptographic operations</li>
<li>Safe to call frequently (respecting rate limits)</li>
<li>Should cache token for duration (1 hour)</li>
</ul>
<h5 id="monitoring-integration"><a class="doc-anchor" href="#monitoring-integration">§</a>Monitoring Integration</h5>
<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="comment">// Use in health check endpoint
</span><span class="kw">async fn </span>health_endpoint(signer: <span class="kw-2">&amp;</span>AzureKeyVaultVrfSigner) -&gt; HealthResponse {
    <span class="kw">match </span>signer.health_check() {
        <span class="prelude-val">Ok</span>(()) =&gt; HealthResponse {
            status: <span class="string">"healthy"</span>,
            keyvault: <span class="string">"accessible"</span>,
            latency_ms: measure_latency(),
        },
        <span class="prelude-val">Err</span>(e) =&gt; HealthResponse {
            status: <span class="string">"unhealthy"</span>,
            keyvault: <span class="string">"error"</span>,
            error: e.to_string(),
        },
    }
}</code></pre></div><h5 id="azure-service-health"><a class="doc-anchor" href="#azure-service-health">§</a>Azure Service Health</h5>
<p>Also consider checking Azure service health:</p>
<ul>
<li>Azure Status: <a href="https://status.azure.com">https://status.azure.com</a></li>
<li>Service Health API: For programmatic checks</li>
<li>Azure Monitor: For metrics and alerts</li>
</ul>
<h5 id="what-to-check"><a class="doc-anchor" href="#what-to-check">§</a>What to Check</h5>
<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">async fn </span>comprehensive_health_check(signer: <span class="kw-2">&amp;</span>AzureKeyVaultVrfSigner) -&gt; <span class="prelude-ty">Result</span>&lt;(), String&gt; {
    <span class="comment">// 1. Token acquisition
    </span><span class="kw">let </span>token = acquire_token().<span class="kw">await
        </span>.map_err(|e| <span class="macro">format!</span>(<span class="string">"Token error: {}"</span>, e))<span class="question-mark">?</span>;

    <span class="comment">// 2. Vault reachability
    </span><span class="kw">let </span>response = reqwest::get(<span class="kw-2">&amp;</span><span class="macro">format!</span>(<span class="string">"{}/keys?api-version=7.4"</span>, vault_url)).<span class="kw">await
        </span>.map_err(|e| <span class="macro">format!</span>(<span class="string">"Network error: {}"</span>, e))<span class="question-mark">?</span>;

    <span class="comment">// 3. HTTP status
    </span><span class="kw">if </span>!response.status().is_success() {
        <span class="kw">return </span><span class="prelude-val">Err</span>(<span class="macro">format!</span>(<span class="string">"HTTP {}"</span>, response.status()));
    }

    <span class="comment">// 4. Response time
    </span><span class="kw">if </span>response_time &gt; Duration::from_secs(<span class="number">1</span>) {
        <span class="kw">return </span><span class="prelude-val">Err</span>(<span class="string">"High latency"</span>.to_string());
    }

    <span class="prelude-val">Ok</span>(())
}</code></pre></div></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-AzureKeyVaultVrfSigner" class="impl"><a href="#impl-Freeze-for-AzureKeyVaultVrfSigner" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.AzureKeyVaultVrfSigner.html" title="struct cardano_vrf::hsm::azure_keyvault::AzureKeyVaultVrfSigner">AzureKeyVaultVrfSigner</a></h3></section><section id="impl-RefUnwindSafe-for-AzureKeyVaultVrfSigner" class="impl"><a href="#impl-RefUnwindSafe-for-AzureKeyVaultVrfSigner" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.AzureKeyVaultVrfSigner.html" title="struct cardano_vrf::hsm::azure_keyvault::AzureKeyVaultVrfSigner">AzureKeyVaultVrfSigner</a></h3></section><section id="impl-Send-for-AzureKeyVaultVrfSigner" class="impl"><a href="#impl-Send-for-AzureKeyVaultVrfSigner" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.AzureKeyVaultVrfSigner.html" title="struct cardano_vrf::hsm::azure_keyvault::AzureKeyVaultVrfSigner">AzureKeyVaultVrfSigner</a></h3></section><section id="impl-Sync-for-AzureKeyVaultVrfSigner" class="impl"><a href="#impl-Sync-for-AzureKeyVaultVrfSigner" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.AzureKeyVaultVrfSigner.html" title="struct cardano_vrf::hsm::azure_keyvault::AzureKeyVaultVrfSigner">AzureKeyVaultVrfSigner</a></h3></section><section id="impl-Unpin-for-AzureKeyVaultVrfSigner" class="impl"><a href="#impl-Unpin-for-AzureKeyVaultVrfSigner" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.AzureKeyVaultVrfSigner.html" title="struct cardano_vrf::hsm::azure_keyvault::AzureKeyVaultVrfSigner">AzureKeyVaultVrfSigner</a></h3></section><section id="impl-UnwindSafe-for-AzureKeyVaultVrfSigner" class="impl"><a href="#impl-UnwindSafe-for-AzureKeyVaultVrfSigner" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.AzureKeyVaultVrfSigner.html" title="struct cardano_vrf::hsm::azure_keyvault::AzureKeyVaultVrfSigner">AzureKeyVaultVrfSigner</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.91.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.91.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/borrow.rs.html#212">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/borrow.rs.html#214">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.91.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/borrow.rs.html#221">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.91.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/borrow.rs.html#222">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.91.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.91.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#785">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#788">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#767-769">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#777">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Same-for-T" class="impl"><a class="src rightside" href="https://docs.rs/typenum/1.19.0/src/typenum/type_operators.rs.html#34">Source</a><a href="#impl-Same-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/typenum/1.19.0/typenum/type_operators/trait.Same.html" title="trait typenum::type_operators::Same">Same</a> for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a class="src rightside" href="https://docs.rs/typenum/1.19.0/src/typenum/type_operators.rs.html#35">Source</a><a href="#associatedtype.Output" class="anchor">§</a><h4 class="code-header">type <a href="https://docs.rs/typenum/1.19.0/typenum/type_operators/trait.Same.html#associatedtype.Output" class="associatedtype">Output</a> = T</h4></section></summary><div class='docblock'>Should always be <code>Self</code></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#827-829">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#831">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#834">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#811-813">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#815">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.91.0/src/core/convert/mod.rs.html#818">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.91.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.91.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>